// 1) Какие бывают алгоритмы сортировок ?

//-Сортировка пузырьком (Bubble Sort):Этот алгоритм просматривает массив несколько раз, сравнивая пары элементов и меняя их местами, если они находятся в неправильном порядке.Сложность времени: O(n^2)

//-Сортировка выбором (Selection Sort):Этот алгоритм находит минимальный элемент и помещает его в начало массива. Затем он повторяет этот процесс для оставшейся части массива.Сложность времени: O(n^2)

//-Быстрая сортировка (Quick Sort):Этот алгоритм использует подход "разделяй и властвуй". Он выбирает опорный элемент и делит массив на две части: элементы меньше опорного и элементы больше опорного. Затем он применяет рекурсивно быструю сортировку к каждой из этих частей.Средняя сложность времени: O(n log n)

//-Циклическая сортировка :Основной идеей алгоритма циклической сортировки является разложение массива на циклы. Затем, внутри этих циклов происходят перестановки элементов до тех пор, пока все циклы не завершатся и массив не будет отсортирован.Сложность алгоритма: O(n2).

// Алгоритмы поиска:

// -Линейный поиск: это самый примитивный алгоритм поиска, который работает как с отсортированными, так и с не отсортированными массивами.

// -Бинарный поиск: Основная идея бинарного поиска заключается в делении массива по полам и отсеивании не подходящей части. Алгоритм имеет смысл использовать только с отсортированными массивами

// -Поиск в ширину и глубину: Поиск в глубину — это алгоритм обхода или поиска в таких структурах данных, как деревья или графы. Основан на такой структуре данных, как стек. Алгоритм начинает работу с корневого узла (в случае графа в качестве корневого узла выбирается какой-либо произвольный узел) и прежде чем вернуться назад, проходит как можно дальше по каждой ветви.

// -Алгоритм Дейкстры: Алгоритм поиска в ширину очень похож на описанный выше алгоритм поиска в глубину, отличается лишь тем, что в начале проходит все соседние узлы начальной вершины, потом все соседние узлы соседних вершин, и так далее, пока не пройдёт весь граф или не найдёт искомую вершину. Ещё одно отличие заключается в том, что основан этот алгоритм на такой структуре данных, как очередь.


// 2) Прочитать про "Операторы и выражения, циклы в JS"


// В JavaScript есть следующие типы операторов. Данный подраздел описывает каждый тип и содержит информацию об их приоритетах друг над другом.

// Операторы присваивания
// Операторы сравнения
// Арифметические операторы
// Битовые (поразрядные) операторы
// Логические операторы
// Строковые операторы
// Условный (тернарный) оператор
// Оператор запятая
// Унарные операторы
// Операторы отношения
// Приоритет операторов


// Выражения

// Выражением является любой корректный блок кода, который возвращает значение.
// Концептуально, существуют два типа выражений: те которые присваивают переменной значение, и те, которые вычисляют значение без его присваивания.

// Выражение x = 7 является примером выражения первого типа. Данное выражение использует оператор = для присваивания переменной x значения 7. Само выражение также равняется 7.

// Код 3 + 4 является примером выражения второго типа. Данное выражение использует оператор "+" для сложения чисел 3 и 4 без присваивания переменной полученного результата 7.

// Все выражения в JavaScript делятся на следующие категории:

// -Арифметические: вычисляются в число,
// -Строковые: вычисляются в текстовую строку,
// -Логические: вычисляются в true или false 
// -Основные выражения: Базовые ключевые слова и основные выражения в JavaScript.
// -Левосторонние выражения: Значениям слева назначаются значения справа.

// циклы в JS:

//реальных циклов всего 3, не стоит их путать с методами перебора..forEach/map/for of /for in и т.д

// 1
while (condition) { };

// 2
do { }
while (condition);

// 3
for (let i = 0; i < 10; i++) {
	console.log('Hello');
}


// 3) Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.

//1 создание объекта person - литеральный способ

const person = {
	id: 1,
	name: 'Evgeniy',
	surname: 'Kazak',
	age: 34,
	showUser: function () {
		return `Имя: ${this.name}, фамилия: ${this.surname}, возраст: ${this.age}`;
	}
}


//2 создание объекта person - конструктор

const person02 = new Object({
	id: 1,
	name: 'Evgeniy',
	surname: 'Kazak',
	age: 34,
	showUser: function () {
		return `Имя: ${this.name}, фамилия: ${this.surname}, возраст: ${this.age}`;
	}
})

//3 создание объекта person - функция конструктор

function Person03(id, name, surname, age) {
	this.id = id;
	this.name = name;
	this.surname = surname;
	this.age = age;
	this.showUser = () => {
		return `Имя: ${this.name}, фамилия: ${this.surname}, возраст: ${this.age}`;
	}
}

const person03 = new Person03(1, 'Evgeniy', 'Kazak', 34);


// создание объекта person - класс

class Person04 {
	constructor(id, name, surname, age) {
		this.id = id;
		this.name = name;
		this.surname = surname;
		this.age = age;
	}
	showUser() {
		return `Имя: ${this.name}, фамилия: ${this.surname}, возраст: ${this.age}`;
	}
}
const person04 = new Person04(1, 'Evgeniy', 'Kazak', 34);


// Cоздать объект Person2, чтобы в нём были доступны методы объекта Person

const person2 = Object.create(person);

console.log(person02.showUser());//Имя: Evgeniy, фамилия: Kazak, возраст: 34


// метод logInfo будет доступен объекту person и его наследникам

person.logInfo = function () {
	return `Имя: ${this.name}. Возраст: ${this.age}.`;
}

// // метод logInfo будет доступен всем объектам
// Object.prototype.logInfo = function () {
// 	return `Name: ${this.name}. Age: ${this.age}.`;
// }


// // создание объекта person2 - метод Object.create
// const person2 = Object.create(person, {
// 	name: { value: 'Any', enumerable: true, writable: true, configurable: true },
// 	age: { value: 24, enumerable: true, writable: true, configurable: true },
// });


// 4) Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от класса Person.


class PersonThree {
	constructor(id, name, age) {
		this.id = id;
		this._name = name;
		this.age = age;
	}
	showId() {
		return this.id;
	}

	get name() {
		return this._name;
	}

	set name(userName) {
		this._name = userName;
	}

}

class Person extends PersonThree {
	constructor(id, name, age, city) {
		super(age, id, name);
		this.city = city;
	}

	place() {
		return `Проживает: ${this.city}`
	}

}

const human = new Person(1, 'Ivan', 32, 'Moscow');

console.log(human);



// 1) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:

// Сложность O(n^2)

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
total = 13;

//result = [4, 9]


const firstSum = (arr, total) => {

	for (let i = 0; i < arr.length; i++) {
		for (let j = i + 1; j < arr.length; j++) {
			if (arr[i] + arr[j] == total) {
				return [arr[i], arr[j]]
			}
		}
	}
}

console.log(firstSum(arr, total));
